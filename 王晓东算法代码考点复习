**王晓东算法代码考点复习

#include <iostream>

typedef int ElemType;

int BinarySort(int A[], int n, int x)
{
	int low = 0, high = n-1, mid;
	while(low<high)
		mid = (low+high) / 2
		if(x==A[mid])
			return mid;
		else if(x>A[mid])
			low = mid + 1;
		else
			high = mid - 1;
	return -1;
}

int title = 1;
int Board[100][100];
void ChessBoard(int tr, int tc, int dr, int dc, int size)
{
	if(size == 1) return;
	int t = title + 1;
	int s = size / 2;
	//左上角
	if(dr<tr+s&&dc<tc+s)
		ChessBoard(tr,tc,dr,dc,s);
	else{
		Board[tr+s-1][tc+s-1] = t;
		ChessBoard(tr,tc,tr+s-1,tc+s-1,s);
	}
	//右上角
	if(dr<tr+s&&dc>=tc+s)
		ChessBoard(tr,tc+s,dr,dc,s);
	else{
		Board[tr+s-1][tc+s] = t;
		ChessBoard(tr,tc+s,tr+s-1,tc+s,s);
	}
	//左下角
	if(dr>=tr+s&&dc<tc+s)
		ChessBoard(tr+s,tc,dr,dc,s);
	else{
		Board[tr+s][tc+s-1] = t;
		ChessBoard(tr,tc,tr+s,tc+s-1,s);
	}
	//左上角
	if(dr<tr+s&&dc<tc+s)
		ChessBoard(tr,tc,dr,dc,s);
	else{
		Board[tr+s-1][tc+s-1] = t;
		ChessBoard(tr,tc,tr+s-1,tc+s-1,s);
	}
	//右下角
	if(dr>=tr+s&&dc>=tc+s)
		ChessBoard(tr+s,tc+s,dr,dc,s);
	else{
		Board[tr+s][tc+s] = t;
		ChessBoard(tr,tc,tr+s,tc+s,s);
	}
}

ElemType *B = (ElemType *)malloc((n + 1) * sizeof(ElemType));	// 辅助数组 B 
void Merge(ElemType A[], int low, int mid, int high) {
/* 表 A 中两段 A[low, mid] 和 A[mid + 1, high] 各自有序，将它们合并成一个有序表 */
	int i , j, k;
    for ( k = low; k <= high; k++) {
        B[k] = A[k];			// 将 A 中所有元素复制到 B 中
    }
    /** k 在 A 中移动， i、j 在 B 中移动，比较，然后复制给 A */
    for ( i = low, j = mid + 1, k = i; i <= mid && j <= high; k++) {
        if (B[i] <= B[j])		// 比较 B 中左右两个子表中的元素
            A[k] = B[i++];		// 较小值复制给 A[k]
        else
            A[k] = B[j++];
    }
    while(i <= mid)
        A[k++] = B[i++];		// 若 B 中右表长度更短，则 左有余，继续复制进去
    while(j <= high)
        A[k++] = B[j++];		// 若左表更短，同理
}

void MergeSort(ElemType A[], int low, int high) {
    /** 递归终止条件，表中仅有一个元素*/
    if (low < high) {			// 归并排序分解成，每两个先成有序，随后不断合并成更大的有序
        int mid = (low + high) / 2;		// 从中间划分两个子序列
        MergeSort(A, low, mid);			// 对左侧子序列进行递归排序
        MergeSort(A, mid + 1, high);	// 对右侧子序列进行递归排序
        Merge(A, low, mid, high);		// 归并
    }
}

void QuickSort(ElemType A[], int low, int high)//快速排序
{
	if(low<high)//跳出递归条件
	{
		int pivotpos = Partition(A, low ,high);//划分
		QuickSort(A,low,pivotpos-1);//左子表递归排序
		QuickSort(A,pivotpos+1,high);//右子表递归排序
	}
}
int Partition(ElemType A[], int low, int high)//一趟划分
{
	ElemType pivot = A[low];//第一个元素作为枢轴
	while(low<high)//跳出循环条件
	{
		while(low<high&&A[high]>=pivot) --high;
		A[low]=A[high];//比枢轴小的移到左边
		while(low<high&&A[low]<=pivot) ++low;
		A[high]=A[low];//比枢轴大的移到右边
	}
	A[low]=pivot;//枢轴元素放到最终位置
	return low;//返回枢轴最终位置
}



int main(int argc, char const *argv[])
{
	
	return 0;
}
